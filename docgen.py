"""Generates human-readable content from a threat model's JSON specification.

The threat model may optionally be specified in Hjson (https://hjson.org/).

Examples:
    $ python docgen.py "threat model example.[h]json"

Todos:
    * Unit tests
"""

import json
import sys
from common import _empty, iter_items #common.py
import model_builder #model_builder.py

SUPPORTED_FORMATS = ['github-flavored-markdown']
DEBUG_PRINT = False

def _main():
    args = get_args()

    with open(args['json_filename'], 'r') as json_file:
        bare_threat_model = None
        if args['json_filename'].endswith('.hjson'):
            import hjson
            bare_threat_model = hjson.load(json_file)
        else:
            bare_threat_model = json.load(json_file)
        built_threat_model = model_builder.get_built_model(bare_threat_model)

        if args['format'] == 'github-flavored-markdown':
            markdown = ("%s%s%s\n%s\n%s" %
                        (get_model_headers(built_threat_model),
                         _get_table_headers(),
                         _get_table_body(built_threat_model),
                         get_countermeasures_list(built_threat_model),
                         get_criteria_list(built_threat_model)))
            with open(args['json_filename'] + ".md", 'w') as markdown_file:
                markdown_file.write(markdown)
        else:
            print_usage()

def get_model_headers(threat_model):
    """Returns name and description string for threat model in GFM format."""
    assert 'name' in threat_model
    assert 'description' in threat_model
    headers = ("<!-- generated by docgen.py. See: "
               "https://github.com/OpenBitcoinPrivacyProject/threat-model-"
               "scoring-system -->\n")
    headers += "%s\n" % threat_model['name']
    headers += "=" * len(threat_model['name'])
    headers += "\n%s\n\n" % threat_model['description']
    return headers

def _get_table_headers():
    return ("Attackers | Attacks | Countermeasures | Criteria\n"
            "--- | --- | --- | ---\n")

def _get_table_body(threat_model):
    """Generates the GFM text of the table body.

    Each attacker may have multiple attacks, countermeasures, etc. and so
    in general each descriptor will only be included in the first row it
    applies to, followed by blank spaces for subsequent rows in the appropriate
    column.
    """
    table_body = ""

    for attacker in iter_items(threat_model, 'attackers'):
        attacker_name = attacker['name']
        attacker_name += get_tags_markdown(iter_items(attacker,
                                                      'printable-tags'))

        dprint("attacker_name = %s" % attacker_name)

        if _empty(attacker, 'attacks'):
            table_body += get_one_row(attacker_name)
            continue

        for attack in attacker['attacks']:
            attack_name = attack['name']
            attack_name += get_tags_markdown(iter_items(attack,
                                                        'printable-tags'))

            dprint("attack_name = %s" % attack_name)

            if _empty(attack, 'countermeasures'):
                table_body += get_one_row(attacker_name, attack_name)
                attacker_name = None #display name only one row per attacker
                continue

            for countermeasure in iter_items(attack, 'countermeasures'):
                countermeasure_text = countermeasure['id']
                if 'description' in countermeasure:
                    countermeasure_text = countermeasure['description']

                countermeasure_text += get_tags_markdown(iter_items(
                    countermeasure, 'printable-tags'))

                dprint("countermeasure_text = %s" % countermeasure_text)

                #countermeasure may contain either 'criteria-groups' array or
                #   'criteria' array. Avoiding both is enforced by
                #   the `validate_json` module.
                if (_empty(countermeasure, 'criteria-groups') and
                        _empty(countermeasure, 'criteria')):
                    table_body += get_one_row(
                        attacker_name, attack_name, countermeasure_text)
                    attacker_name = None #display name only one row per attacker
                    attack_name = None #display name only one row per attack
                    continue

                elif not _empty(countermeasure, 'criteria-groups'):
                    for criteria_group in iter_items(countermeasure,
                                                     'criteria-groups'):
                        table_body += _get_table_body_criteria_group_recurse(
                            threat_model, criteria_group, attacker_name,
                            attack_name, countermeasure_text)

                        #reset, so we display name only one row per attacker
                        attacker_name = None
                        #reset, so we display name only one row per attack
                        attack_name = None
                        #reset, so we display once per countermeasure
                        countermeasure_text = None

                elif not _empty(countermeasure, 'criteria'):
                    table_body += _get_table_body_criteria_group_recurse(
                        threat_model, countermeasure, attacker_name,
                        attack_name, countermeasure_text)

                    #reset, so we display name only one row per attacker
                    attacker_name = None
                    #reset, so we display name only one row per attack
                    attack_name = None
                    #reset, so we display once per countermeasure
                    countermeasure_text = None

    return table_body

def get_tags_markdown(printable_tags):
    """Get a string to append to markdown for a list of tags.

    An array of tags may apply to an attacker, an attack, a counteremeasure, or
    a criterion. It may be applied within the threat model itself, or in the
    arrays of countermeasures or criteria below the threat model in the JSON
    specification.

    Args:
        printable_tags (List[str]): A list of tags that will be printed

    Returns:
        str: The markdown, or empty string if none needs to be generated.
    """
    MARKDOWN_HEADER = '<BR><EM>Tags:</EM> '

    if len(printable_tags) == 0:
        return ""
    else:
        markdown = MARKDOWN_HEADER
        for tag in printable_tags:
            markdown += "<CODE>%s</CODE> " % tag
        return markdown

def _get_table_body_criteria_group_recurse(threat_model, criteria_container,
                                           attacker_name, attack_name,
                                           countermeasure_text,
                                           num_rows_printed=0):
    """Get the table body contents for criteria or a criteria group.

    This may recurse if a criteria group is provided, as it may contain criteria
    and/or child criteria-groups.

    Args:
        threat_model (`dict`): The threat model object.
        criteria_container (`dict`): Either the countermeasure containing a
            `criteria` array, or a criteria group within a countermeasure.
    """
    body = ""

    dprint(("criteria_group or countermeasure='%s' attacker_name='%s' "
            "attack_name='%s' countermeasure_text='%s' num_rows_printed=%d") %
           (str(criteria_container), attacker_name, attack_name,
            countermeasure_text, num_rows_printed))

    if (_empty(criteria_container, 'criteria') and
            _empty(criteria_container, 'criteria-groups') and
            num_rows_printed == 0):
        #no actual criteria to be found under this countermeasure, so just
        #print everything else.
        return get_one_row(attacker_name, attack_name, countermeasure_text)

    for criterion in iter_items(criteria_container, 'criteria'):
        criterion_text = criterion['id']

        criterion_text += get_tags_markdown(iter_items(criterion,
                                                       'printable-tags'))

        dprint("criterion_text=%s" % criterion_text)
        num_rows_printed += 1
        body += get_one_row(
            attacker_name, attack_name, countermeasure_text, criterion_text)
        attacker_name = None #display name only one row per attacker
        attack_name = None #display name only one row per attack
        countermeasure_text = None #display once per countermeasure

    for criteria_group in iter_items(criteria_container, 'criteria-groups'):
        body += _get_table_body_criteria_group_recurse(
            threat_model, criteria_group, attacker_name, attack_name,
            countermeasure_text, num_rows_printed)
        attacker_name = None #display name only one row per attacker
        attack_name = None #display name only one row per attack
        countermeasure_text = None #display once per countermeasure

    return body

def get_countermeasures_list(threat_model):
    """Returns GFM string representing the list of countermeasures."""
    counterm_section = ("## Countermeasures list\n\n"
                        "ID | Description\n"
                        "--- | ---\n")
    for counterm in threat_model['countermeasures']:
        description = counterm['description']
        description += get_tags_markdown(iter_items(counterm, 'printable-tags'))
        comment = ''
        if 'comment' in counterm:
            comment = "<br><br> _%s_" % counterm['comment']
        counterm_section += ("%s | %s%s\n" % (counterm['id'],
                                              description,
                                              comment))
    return counterm_section

def get_criteria_list(threat_model):
    """Returns GFM string representing the list of criteria."""
    criteria_section = ("## Criteria list\n\n"
                        "ID | Description\n"
                        "--- | ---\n")
    for criterion in threat_model['criteria']:
        description = criterion['description']
        description += get_tags_markdown(iter_items(criterion,
                                                    'printable-tags'))
        comment = ''
        if 'comment' in criterion:
            comment = "<br><br> _%s_" % criterion['comment']
        criteria_section += ("%s | %s%s\n" % (criterion['id'],
                                              description,
                                              comment))
    return criteria_section

def get_one_row(attacker_name=None, attack_name=None, countermeasure_text=None,
                criterion_text=None):
    """Get one row of the table based on the provided string values."""

    row = ""
    if attacker_name is None:
        row += "   "
    else:
        row += attacker_name
    row += " | "
    if attack_name is None:
        row += "   "
    else:
        row += attack_name
    row += " | "
    if countermeasure_text is None:
        row += "   "
    else:
        row += countermeasure_text
    row += " | "
    if criterion_text is None:
        row += "   "
    else:
        row += criterion_text
    row += "\n"
    return row

def get_args():
    """Reads command line arguments.
    Returns `dict`:
        * 'json_filename'
    """
    args = dict()

    args['format'] = 'github-flavored-markdown'

    args['json_filename'] = None
    if len(sys.argv) == 2:
        args['json_filename'] = str(sys.argv[1])
    else:
        print_usage()

    return args

def print_json(json_obj):
    """Prints the contents of the JSON object in pretty format to stdout."""
    print json.dumps(json_obj, indent=4, sort_keys=True)

def print_usage():
    """Prints syntax for usage and exits the program."""
    print(("Usage:\n"
           "\tpython docgen.py threat-model-file.json"))
    sys.exit()

def dprint(data):
    """Print debug data, if enabled."""
    if DEBUG_PRINT:
        print "DEBUG: %s" % str(data)

if __name__ == '__main__':
    _main()
